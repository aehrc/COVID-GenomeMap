<!DOCTYPE html>
<meta charset="utf-8">
<style type="text/css">
 

.legend rect {
  fill:white;
  stroke:black;
  opacity:0.8;}

path { 
    stroke: steelblue;
    stroke-width: 2;
    fill: none;
}

.line {
        fill: none;
        stroke: steelblue;
        stroke-width: 1.5px;
    }
.zoom {
  cursor: move;
  fill: none;
  pointer-events: all;
  }

.axis path,
.axis line {
    fill: none;
    stroke: black;
    stroke-width: 2;
    shape-rendering: crispEdges;
}

.legend rect {
  fill:white;
  stroke:black;
  opacity:0.8;}




</style>
<body>
<svg width="960" height="600"></svg>
<script src="//d3js.org/d3.v5.min.js"></script>

<script>




var svg = d3.select("svg");


margin = {top: 10, right: 20, bottom: 210, left: 30},

width = +svg.attr("width") - margin.left - margin.right,
height = +svg.attr("height") - margin.top - margin.bottom;



const tooltip = svg.append("g")
    .attr("class", "tooltip")
    .style("display", "none");

  tooltip.append("rect")
    .attr("width", 50)
    .attr("height", 40)
    .attr("fill", "white")
    .style("opacity", 0.5);

  tooltip.append("text")
    .attr('class', 'id_feature')
    .attr("x", 25)
    .attr("dy", "1.2em")
    .style("text-anchor", "middle")
    .attr("font-size", "14px");

  tooltip.append("text")
    .attr('class', 'value_feature')
    .attr("x", 25)
    .attr("dy", "2.4em")
    .style("text-anchor", "middle")
    .attr("font-size", "14px")
    .attr("font-weight", "bold");



let t;
var k = height / width,
    x0 = [0, 1],
    y0 = [0, 1],
    x = d3.scaleLinear().domain(x0).range([0, width]),
    y = d3.scaleLinear().domain(y0).range([height, 0]);

var xAxis = d3.axisBottom(x),
    yAxis = d3.axisLeft(y);


var Line_chart = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .attr("clip-path", "url(#clip)");


var focus = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");




var brush = d3.brush().on("end", brushended),
    idleTimeout,
    idleDelay = 350;

// Define the div for the tooltip
var div = d3.select("body").append("div") 
    .attr("class", "tooltip")       
    .style("opacity", 0);

function unique(x) {
    return x.reverse().filter(function (e, i, x) {return x.indexOf(e, i+1) === -1;}).reverse();
}

d3.csv("/static/covid19_kmerSigs.csv").then(function(points, error) {

  circles = Line_chart.selectAll("circle")
    .data(points)
    .enter().append("circle")
      .attr("cx", function(d) { return x(d.PCA1); })
      .attr("cy", function(d) { return y(d.PCA2); })
      .attr("class", function(d){ return d.id;})
      .attr("r", function(d){ return (d.mSize/d.bSize); })
      .style("fill", function(d) { return d.color; })
      .attr("data-legend",function(d) { return d.class;})
      .style("opacity", 0.5)
      .on("mouseover", function(){
        // console.log(d.PCA1, d.PCA2, d.id, d.class);
        console.log("mouseover");
      });
        



gX = focus.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height + ")")
        // .style("stroke-dasharray", ("3, 3"))
        .call(xAxis);

gY = focus.append("g")
        .attr("class", "axis axis--y")
        // .attr("transform", "translate(0," + width + ")")
        .call(yAxis);

svg.selectAll(".domain")
    .style("display", "none");

svg.append("g")
    .attr("class", "brush")
    .call(brush);

 circles
    .on("mouseover", () => {
      clearTimeout(t);
      svg.select('.tooltip').style('display', null);
    })
    .on("mouseout", () => {
      clearTimeout(t);
      t = setTimeout(() => { svg.select('.tooltip').style('display', 'none'); }, 250);
    })
    .on("mousemove", function(d) {
      clearTimeout(t);
      const tooltip = svg.select('.tooltip').style('display', null);
      tooltip
        .select("text.id_feature")
        .text(`${d.class}`);
      tooltip.select('text.value_feature')
        .text(d.id);
      tooltip
        .attr('transform', `translate(${[d3.mouse(this)[0] - 5, d3.mouse(this)[1] - 25]})`);
    });




svg.select('.brush')
    .on('mousemove mousedown', function () {
      dispatchClickToBar(d3.event.pageX, d3.event.pageY, d3.event.clientX, d3.event.clientY, 'mousemove');
      // console.log(d3.event.pageX, d3.event.pageY);
    })
    .on('mouseout', function () {
      clearTimeout(t);
      t = setTimeout(() => { svg.select('.tooltip').style('display', 'none'); }, 250);
      // console.log("mouseout");
    })


var legendData = d3.values(points.map(function (d) { return d.color; }));
    var unique_values = unique(legendData.map(function(d){return d}));

    var legendDataid = d3.values(points.map(function (d) { return d.class; }));
    var unique_values_id = unique(legendDataid.map(function(d){return d}));


    var legend = svg.selectAll(".legend")
      .data(unique_values)
    .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });


    legend.append("rect")
      .attr("x",  130)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", function(d) {return d;});

    legend.append("text")
      .attr("x",  120)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d, i) { return unique_values_id[i]; });





});

function dispatchClickToBar(pageX, pageY, clientX, clientY, type) {
  const elems = document.elementsFromPoint(pageX, pageY);

  const elem = elems.find(e => e.className.baseVal === 'bar');
  if (elem) {
    const new_click_event = new MouseEvent(type, {
      pageX: pageX,
      pageY: pageY,
      clientX: clientX,
      clientY: clientY,
      bubbles: true,
      cancelable: true,
      view: window
    });
    elem.dispatchEvent(new_click_event);
  } else {
    clearTimeout(t);
    t = setTimeout(() => { svg.select('.tooltip').style('display', 'none'); }, 5);
  }
}

function brushended() {
  var s = d3.event.selection;
  if (!s) {
    if (!idleTimeout) return idleTimeout = setTimeout(idled, idleDelay);
    x.domain(x0);
    y.domain(y0);
  } else {
    x.domain([s[0][0], s[1][0]].map(x.invert, x));
    y.domain([s[1][1], s[0][1]].map(y.invert, y));
    svg.select(".brush").call(brush.move, null);
  }
  zoom();
}

function idled() {
  idleTimeout = null;
}

function zoom() {
  var t = svg.transition().duration(750);
  svg.select(".axis--x").transition(t).call(xAxis);
  svg.select(".axis--y").transition(t).call(yAxis);
  svg.selectAll("circle").transition(t)
      .attr("cx", function(d) { return x(d.PCA1); })
      .attr("cy", function(d) { return y(d.PCA2); })
      .attr("class", "bar");
}

</script>

</body>