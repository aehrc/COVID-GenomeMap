<!DOCTYPE html>
<meta charset="utf-8">
<style> /* set the CSS */

body { font: 12px Arial;}

path { 
    stroke: transparent;
    stroke-width: 2;
    fill: none;
}

.line {
        fill: none;
        stroke: transparent;
        stroke-width: 1.5px;
    }
.zoom {
  cursor: move;
  fill: none;
  pointer-events: all;
  }

.axis path,
.axis line {
    fill: none;
    stroke: grey;
    stroke-width: 1;
    shape-rendering: crispEdges;
}

.legend rect {
  fill:white;
  stroke:black;
  opacity:0.8;}


.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}


</style>
<body>

<!-- load the d3.js library -->    
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
<script src="https://d3js.org/d3.v5.js"></script>
<!-- <script src="//d3js.org/d3.v5.js"></script> -->
<script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
<!-- <script src="/static/js/d3.legend.js"></script> -->
<svg width="960" height="500"></svg>
<!-- <div id="container"></div> -->
<script>



var svgg = d3.select("svg");

let zoomTrans = {x:0, y:0, scale:1}

margin = {top: 10, right: 20, bottom: 110, left: 30},
margin2 = {top: 430, right: 20, bottom: 30, left: 30},
width = +svgg.attr("width") - margin.left - margin.right,
height = +svgg.attr("height") - margin.top - margin.bottom,
height2 = +svgg.attr("height") - margin2.top - margin2.bottom;

// var bisectDate = d3.bisector(function(d) { return d.dt; }).left;


// var x = d3.scaleTime().range([0, width]),
var x = d3.scaleLinear()
    .domain([0, 1])
    .range([ 0, width ]),
    x2 = d3.scaleLinear()
    .domain([0, 1])
    .range([ 0, width ]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var xAxis = d3.axisBottom(x),
    xAxis2 = d3.axisBottom(x2),
    yAxis = d3.axisLeft(y);

var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);

var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);



var tip = d3.tip()
      .attr("class", "d3-tip")
      .offset([-10, 0])
      .html(function(d) {
        return "ID" + ": " + d.id + "<br>" + "Class" + ": " + d.class
});


var svg = svgg
    .append("svg:svg")
      .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append("svg:g")
    .attr("id", "group")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


  // svg.call(tip);


var view = svg.append("rect")
    .attr("class", "view")
    .attr("x", 0.5)
    .attr("y", 0.5)
    .attr("opacity", 0)
    .attr("width", width + margin.left + margin.right - 1)
    .attr("height", height + margin.top + margin.bottom - 1);



var clip = svg.append("defs").append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("width", width)
        .attr("height", height)
        .attr("x", 0)
        .attr("y", 0); 

var Line_chart = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .attr("clip-path", "url(#clip)");


var focus = svg.append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var focus2 = svg.append("g") 
        .attr("class", "focus2")
        .style("display", "none")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


focus2.append("circle")
    .attr("class", "y")
    .attr("cx", 100)
    .attr("cy", 200)
    .style("fill", "none")
    .style("stroke", "steelblue")
    .attr("r", 4)
    .attr("clip-path", "url(#clip)"); 
    
focus2.append("text")
    .attr("class", "ytext")
    .attr("dy", ".35em")
    .attr("clip-path", "url(#clip)");

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");


svg.attr("width", width + margin.left + margin.right)
    .attr("height", height  + margin.top + margin.bottom)
    .append("g")
    .attr("id", "the_g")
    .attr("transform", 
              "translate(" + margin.left + "," + margin.top + ")");




function unique(x) {
    return x.reverse().filter(function (e, i, x) {return x.indexOf(e, i+1) === -1;}).reverse();
}


var priceSeries = d3.line()
  .x(function(d) { return x(d.PCA1); })
  .y(function(d) { return y(d.PCA2); });



var PCA1 = [];
var PCA2 = [];
var gX;
var gY;

var sites = [];
d3.csv("/static/covid19_kmerSigs.csv").then(function(data, error) {
    
    data.sort(function(a, b){
    return a.PCA1-b.PCA1
  });


    data.forEach(function(d){
      PCA1.push(d.PCA1);
      PCA2.push(d.PCA2);
      sites.push({"x": d.PCA1, "y": d.PCA2});
    });



  x.domain(d3.extent(data, function(d) { return d.PCA1; }));
  y.domain([0, d3.max(data, function (d) { return d.PCA2; })]);
  x2.domain(x.domain());
  y2.domain(y.domain());


gX = focus.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

gY = focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

Line_chart.append('g')
        .attr('class', 'circles')
        .selectAll('circle')
        .data(data)
      .enter().append("circle")
        .attr("r", function(d){ return (d.mSize/d.bSize); })
        .attr("cx", function(d) { return x(d.PCA1); })
        .attr("cy", function(d) { return y(d.PCA2); })
        .attr("class", function(d){ return d.id;})
        .attr("data-legend",function(d) { return d.class;})
        .style("opacity", 0.3)
        .style("fill", function(d) { return d.color; })
        .on("mouseover", tip.show)
        .on("mouseout", tip.hide);



Line_chart.append("svg:path")
    .data([data])
    .attr("class", "line")
    .attr("d", priceSeries);



 context.selectAll('circle')
        .data(data)
      .enter().append("circle")
        .attr("r", function(d){ return (d.mSize/d.bSize); })
        .attr("cx", function(d) { return x2(d.PCA1); })
        .attr("cy", function(d) { return y2(d.PCA2); })
        .attr("class", function(d){ return d.id;})
        .attr("data-legend",function(d) { return d.class;})
        .style("opacity", 0.5)
        .style("fill", function(d) { return d.color; });


context.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height2 + ")")
      .call(xAxis2);

context.append("g")
      .attr("class", "brush")
      .call(brush)
      .call(brush.move, x.range());


  svg.append("rect")
      .attr("class", "zoom")
      .attr("id", "groups")
      .attr("width", width + 20)
      .attr("height", height + 20)
      .style("opacity", 0)
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
      .style("fill", "none")
      .style("pointer-events", "all")
      .on("mouseover", function() { focus2.style("display", null); })
      .on("mouseout", function() { focus2.style("display", "none"); })
      .on("mousemove", mousemove)
      .call(zoom);




    svg.append("text")
    .attr("class", "x label")
    .attr("text-anchor", "end")
    .attr("x", width  /2)
    .attr("y", height  + 50)
    .text("PCA1");



    // Add the text label for the Y axis
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", margin.left - 40)
        .attr("x",0 - (height  / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text("PCA2");


    var legendData = d3.values(data.map(function (d) { return d.color; }));
    var unique_values = unique(legendData.map(function(d){return d}));

    var legendDataid = d3.values(data.map(function (d) { return d.class; }));
    var unique_values_id = unique(legendDataid.map(function(d){return d}));


    var legend = svg.selectAll(".legend")
      .data(unique_values)
    .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });


    legend.append("rect")
      .attr("x",  130)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", function(d) {return d;});

    legend.append("text")
      .attr("x",  120)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d, i) { return unique_values_id[i]; });



    

      function mouseDate(transform) {


      var g = d3.select("#groups")._groups[0][0]
      // console.log(d3.mouse(g)[0]);

     // var mouse_position = (d3.mouse(g)[0] - transform.x)/transform.k;

      var scale_x = transform.rescaleX(x);
      var mouse_position = scale_x.invert((d3.mouse(g)[0]) * transform.k);
      var offset = scale_x.invert(transform.x * transform.k)

      var x0 = mouse_position - offset;
     
      i = d3.bisect(PCA1, x0);

      d0 = data[i - 1],
      d1 = data[i],
      d = x0 - d0.PCA1 > d1.PCA1 - x0 ? d1 : d0;


      return d
  };






  function mousemove() {
    var transform = d3.zoomTransform(this);

    var xt = transform.rescaleX(x), yt = transform.rescaleY(y);

    // console.log("#############")
    // console.log(xt.range());
    // console.log("#############")

    zoomTrans.x = transform.x;
    zoomTrans.y = transform.y;
    zoomTrans.scale = transform.k;


    d = mouseDate(transform);
    // console.log(d);
   mouse_x = d3.mouse(this)[0];
   mouse_y = d3.mouse(this)[1];

   var test_x = (mouse_x - transform.x)/transform.k;
   var test_y = (mouse_y - transform.y)/transform.k;

  
    focus2.select("circle.y")
      .attr('cx', function() {
                  return x(d.PCA1);
                })
      .attr('cy', function() {
                  return y(d.PCA2);
                });
    focus2.select("text")
       .text(d.id)
       .attr('x', function() {
                  return x(d.PCA1);
       })
       .attr('y', function() {
                  return y(d.PCA2);
       });
     

  };//end of mousemove function



});


function brushed() {
  if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
  var s = d3.event.selection || x2.range();
  x.domain(s.map(x2.invert, x2));
  // Line_chart.select(".line").attr("d", line);
   context
      .selectAll("circle")
      .attr('cx', function(d) {return x2(d.PCA1)})
      .attr('cy', function(d) {return y2(d.PCA2)});

  focus.select(".axis--x").call(xAxis);
  svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
      .scale(width / (s[1] - s[0]))
      .translate(-s[0], 0));
}

function zoomed() {
  if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return; // ignore zoom-by-brush

  zoomTrans.x = d3.event.transform.x;
  zoomTrans.y = d3.event.transform.y;
  zoomTrans.scale = d3.event.transform.k;

  // console.log("/////////////////////////")
  // console.log(zoomTrans.x, zoomTrans.y, zoomTrans.scale);
  // console.log("/////////////////////////")

  var t = d3.event.transform;
  x.domain(t.rescaleX(x2).domain());
  Line_chart
  .selectAll("circle")
      .attr('cx', function(d) {return x(d.PCA1)})
      .attr('cy', function(d) {return y(d.PCA2)});
  focus.select(".axis--x").call(xAxis);
  context.select(".brush").call(brush.move, x.range().map(t.invertX, t));


   Line_chart.select(".line")
     .attr("d",priceSeries.x(function(d) { return x(d.PCA1);})
              .y(function(d) { return y(d.PCA2);}));



    focus2.select("circle.y")
       .classed("zoomed", true)
       .attr("id","one")
       .attr('cx', function() {return t.applyX(x(d.PCA1)); })
       .attr('cy', function() {return y(d.PCA2); });       
    focus2.select("text")
       .text(d.id)
       .attr('x', function() { return t.applyX(x(d.PCA1))+10;})
       .attr('y',function() {return y(d.PCA2) });

}


function type(d) {
  d.PCA1 = d.PCA1;
  d.PCA2 = d.PCA2;
  return d;
} 


// callback to highlight a point
function highlight(d) {
  // no point to highlight - hide the circle and clear the text
  if (!d) {
    d3.select('.highlight-circle').style('display', 'none');
    svg.text('');

  // otherwise, show the highlight circle at the correct position
  } else {
    d3.select('.highlight-circle')
      .style('display', '')
      .style('stroke', colorScale(d.y))
      .attr('cx', xScale(d.x))
      .attr('cy', yScale(d.y));

    // format the highlighted data point for inspection
    svg.html(JSON.stringify(d)
      .replace(/([{}])/g, '')
      .replace(/"(.+?)":/g, '<strong style="width: 40px; display: inline-block">$1:</strong> ')
      .replace(/,/g, '<br>'));
  }
}





</script>
</body>